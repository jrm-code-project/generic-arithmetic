;;; -*- Lisp -*-

(in-package "GENERIC-ARITHMETIC")

(defun * (&rest numbers)
  #.(documentation 'cl:* 'cl:function)
  (fold-left #'multiply2 1 numbers))

(defun + (&rest numbers)
  #.(documentation 'cl:+ 'cl:function)
  (fold-left #'add2 0 numbers))

(defun - (leftmost &rest rights)
  #.(documentation 'cl:- 'cl:function)
  (cond ((consp rights) (fold-left #'subtract2 leftmost rights))
        ((null rights)  (negate leftmost))
        (t
         (error "Invalid arguments to -: ~a" rights))))

(defun / (leftmost &rest rights)
  #.(documentation 'cl:/ 'cl:function)
  (cond ((consp rights) (fold-left #'divide2 leftmost rights))
        ((null rights)  (reciprocal leftmost))
        (t
         (error "Invalid arguments to /: ~a" rights))))

(defgeneric acos (number)
  (:documentation #.(documentation 'cl:acos 'cl:function))
  (:method ((number number))
    (cl:acos number)))

(defgeneric add2 (left right)
  (:documentation "Add LEFT and RIGHT.")
  (:method ((left (eql 0)) right)
    right)
  (:method ((left (eql 0.0)) right)
    right)
  (:method ((left (eql 0.0d0)) right)
    right)
  (:method (left (right (eql 0)))
    left)
  (:method (left (right (eql 0.0)))
    left)
  (:method (left (right (eql 0.0d0)))
    left)
  (:method ((left number) (right number))
    (cl:+ left right)))

(defgeneric asin (number)
  (:documentation #.(documentation 'cl:asin 'cl:function))
  (:method ((number number))
    (cl:asin number)))

(defgeneric atan (number &optional denominator)
  (:documentation "Compute the arctangent of NUMBER. If DENOMINATOR is provided, compute atan(NUMBER / DENOMINATOR).")
  (:method ((number number) &optional denominator)
    (if (null denominator)
        (cl:atan number)
        (cl:atan number denominator))))

(defgeneric cos (number)
  (:documentation #.(documentation 'cl:cos 'cl:function))
  (:method ((number number))
    (cl:cos number)))

(defgeneric cube (number)
  (:documentation "Compute the cube of NUMBER.")
  (:method ((number number))
    (cl:* number number number)))

(defgeneric divide2 (left right)
  (:documentation "Divide LEFT by RIGHT.")
  (:method ((left (eql 1)) right)
    (reciprocal right))
  (:method ((left (eql 1.0)) right)
    (reciprocal right))
  (:method ((left (eql 1.0d0)) right)
    (reciprocal right))
  (:method ((left number) (right number))
    (cl:/ left right)))

(defgeneric exp (number)
  (:documentation #.(documentation 'cl:exp 'cl:function))
  (:method ((number number))
    (cl:exp number)))

(defgeneric expt (base exponent)
  (:documentation #.(documentation 'cl:expt 'cl:function))
  (:argument-precedence-order exponent base)
  (:method (base (exponent (eql 0)))
    1)
  (:method (base (exponent (eql 1)))
    base)
  (:method (base (exponent integer))
    (cond ((minusp exponent) (expt (reciprocal base) (- exponent)))
          ((evenp exponent)  (expt (* base base) (/ exponent 2)))
          (t                 (* base (expt base (- exponent 1))))))
  (:method ((base (eql 0)) exponent)
    0)
  (:method ((base (eql 1)) exponent)
    1)
  (:method ((base number) (exponent number))
    (cl:expt base exponent)))

(defgeneric log (number &optional base)
  (:documentation #.(documentation 'cl:log 'cl:function))
  (:method ((number number) &optional base)
    (cl:log number (or base (cl:exp 1.0d0)))))

(defgeneric multiply2 (left right)
  (:documentation "Multiply LEFT by RIGHT.")
  (:method ((left (eql 0)) right)
    0)
  (:method ((left (eql 0.0)) right)
    0.0)
  (:method ((left (eql 0.0d0)) right)
    0.0d0)
  (:method ((left (eql 1)) right)
    right)
  (:method ((left (eql 1.0)) right)
    (coerce right 'single-float))
  (:method ((left (eql 1.0d0)) right)
    (coerce right 'double-float))
  (:method ((left number) (right number))
    (cl:* left right)))

(defgeneric negate (number)
  (:documentation "Return (- number)")
  (:method ((number number))
    (cl:- number)))

(defgeneric reciprocal (number)
  (:documentation "Return 1/number.")
  (:method ((number number))
    (cl:/ 1 number)))

(defgeneric sin (number)
  (:documentation #.(documentation 'cl:sin 'cl:function))
  (:method ((number number))
    (cl:sin number)))

(defgeneric sqrt (number)
  (:documentation #.(documentation 'cl:sqrt 'cl:function))
  (:method ((number number))
    (cl:sqrt number)))

(defgeneric square (number)
  (:documentation "Compute the square of NUMBER.")
  (:method ((number number))
    (cl:* number number)))

(defgeneric subtract2 (left right)
  (:documentation "Subtract RIGHT from LEFT.")
  (:method ((left (eql 0)) right)
    (- right))
  (:method ((left (eql 0.0)) right)
    (- right))
  (:method ((left (eql 0.0d0)) right)
    (- right))
  (:method ((left number) (right number))
    (cl:- left right)))

(defgeneric tan (number)
  (:documentation #.(documentation 'cl:tan 'cl:function))
  (:method ((number number))
    (cl:tan number)))

(defgeneric 1+ (number)
  (:documentation #.(documentation 'cl:1+ 'cl:function))
  (:method ((number number))
    (add2 number 1)))

(defgeneric 1- (number)
  (:documentation #.(documentation 'cl:1- 'cl:function))
  (:method ((number number))
    (subtract2 number 1)))

(defgeneric abs (number)
  (:documentation #.(documentation 'cl:abs 'cl:function))
  (:method ((number number))
    (cl:abs number)))

(defgeneric acosh (number)
  (:documentation #.(documentation 'cl:acosh 'cl:function))
  (:method ((number number))
    (cl:acosh number)))

(defgeneric asinh (number)
  (:documentation #.(documentation 'cl:asinh 'cl:function))
  (:method ((number number))
    (cl:asinh number)))

(defgeneric atanh (number)
  (:documentation #.(documentation 'cl:atanh 'cl:function))
  (:method ((number number))
    (cl:atanh number)))

(defgeneric ceiling (number &optional divisor)
  (:documentation #.(documentation 'cl:ceiling 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:ceiling number)
        (cl:ceiling number divisor))))

(defgeneric cis (number)
  (:documentation #.(documentation 'cl:cis 'cl:function))
  (:method ((number number))
    (cl:cis number)))

(defgeneric complex (realpart &optional imagpart)
  (:documentation #.(documentation 'cl:complex 'cl:function))
  (:method ((realpart number) &optional imagpart)
    (cl:complex realpart imagpart)))

(defgeneric conjugate (number)
  (:documentation #.(documentation 'cl:conjugate 'cl:function))
  (:method ((number number))
    (cl:conjugate number)))

(defgeneric cosh (number)
  (:documentation #.(documentation 'cl:cosh 'cl:function))
  (:method ((number number))
    (cl:cosh number)))

(defgeneric decode-float (float)
  (:documentation #.(documentation 'cl:decode-float 'cl:function))
  (:method ((float single-float))
    (cl:decode-float float))
  (:method ((float double-float))
    (cl:decode-float float)))

(defgeneric denominator (rational)
  (:documentation #.(documentation 'cl:denominator 'cl:function))
  (:method ((rational ratio))
    (cl:denominator rational)))

(defgeneric fceiling (number &optional divisor)
  (:documentation #.(documentation 'cl:fceiling 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:fceiling number)
        (cl:fceiling number divisor))))

(defgeneric ffloor (number &optional divisor)
  (:documentation #.(documentation 'cl:ffloor 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:ffloor number)
        (cl:ffloor number divisor))))

(defgeneric float (number &optional prototype)
  (:documentation #.(documentation 'cl:float 'cl:function))
  (:method ((number number) &optional prototype)
    (if (null prototype)
        (cl:float number)
        (cl:float number prototype))))

(defgeneric float-digits (float)
  (:documentation #.(documentation 'cl:float-digits 'cl:function))
  (:method ((float single-float))
    (cl:float-digits float))
  (:method ((float double-float))
    (cl:float-digits float)))

(defgeneric float-precision (float)
  (:documentation #.(documentation 'cl:float-precision 'cl:function))
  (:method ((float single-float))
    (cl:float-precision float))
  (:method ((float double-float))
    (cl:float-precision float)))

(defgeneric float-radix (float)
  (:documentation #.(documentation 'cl:float-radix 'cl:function))
  (:method ((float single-float))
    (cl:float-radix float))
  (:method ((float double-float))
    (cl:float-radix float)))

(defgeneric float-sign (float1 &optional float2)
  (:documentation #.(documentation 'cl:float-sign 'cl:function))
  (:method ((float1 single-float) &optional float2)
    (if (null float2)
        (cl:float-sign float1)
        (cl:float-sign float1 float2)))
  (:method ((float1 double-float) &optional float2)
    (if (null float2)
        (cl:float-sign float1)
        (cl:float-sign float1 float2))))

(defgeneric floor (number &optional divisor)
  (:documentation #.(documentation 'cl:floor 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:floor number)
        (cl:floor number divisor))))

(defgeneric fround (number &optional divisor)
  (:documentation #.(documentation 'cl:fround 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:fround number)
        (cl:fround number divisor))))

(defgeneric ftruncate (number &optional divisor)
  (:documentation #.(documentation 'cl:ftruncate 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:ftruncate number)
        (cl:ftruncate number divisor))))

(defgeneric imagpart (number)
  (:documentation #.(documentation 'cl:imagpart 'cl:function))
  (:method ((number number))
    (cl:imagpart number)))

(defgeneric integer-decode-float (float)
  (:documentation #.(documentation 'cl:integer-decode-float 'cl:function))
  (:method ((float single-float))
    (cl:integer-decode-float float))
  (:method ((float double-float))
    (cl:integer-decode-float float)))

(defgeneric max2 (left right)
  (:documentation #.(documentation 'cl:max 'cl:function))
  (:method ((left number) (right number))
    (cl:max left right)))

(defun max (leftmost &rest more-numbers)
  (:documentation #.(documentation 'cl:max 'cl:function))
  (fold-left #'max2 leftmost more-numbers))

(defgeneric min2 (left right)
  (:documentation #.(documentation 'cl:min 'cl:function))
  (:method ((left number) (right number))
    (cl:min left right)))

(defun min (leftmost &rest more-numbers)
  (:documentation #.(documentation 'cl:min 'cl:function))
  (fold-left #'min2 leftmost more-numbers))

(defgeneric mod (number divisor)
  (:documentation #.(documentation 'cl:mod 'cl:function))
  (:method ((number number) (divisor number))
    (cl:mod number divisor)))

(defgeneric numerator (rational)
  (:documentation #.(documentation 'cl:numerator 'cl:function))
  (:method ((rational ratio))
    (cl:numerator rational)))

(defgeneric phase (number)
  (:documentation #.(documentation 'cl:phase 'cl:function))
  (:method ((number number))
    (cl:phase number)))

(defgeneric random (arg)
  (:documentation #.(documentation 'cl:random 'cl:function))
  (:method ((arg number))
    (cl:random arg)))

(defgeneric rational (number)
  (:documentation #.(documentation 'cl:rational 'cl:function))
  (:method ((number number))
    (cl:rational number)))

(defgeneric rationalize (number)
  (:documentation #.(documentation 'cl:rationalize 'cl:function))
  (:method ((number number))
    (cl:rationalize number)))

(defgeneric realpart (number)
  (:documentation #.(documentation 'cl:realpart 'cl:function))
  (:method ((number number))
    (cl:realpart number)))

(defgeneric rem (number divisor)
  (:documentation #.(documentation 'cl:rem 'cl:function))
  (:method ((number number) (divisor number))
    (cl:rem number divisor)))

(defgeneric round (number &optional divisor)
  (:documentation #.(documentation 'cl:round 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:round number)
        (cl:round number divisor))))

(defgeneric scale-float (float integer)
  (:documentation #.(documentation 'cl:scale-float 'cl:function))
  (:method ((float single-float) (integer integer))
    (cl:scale-float float integer))
  (:method ((float double-float) (integer integer))
    (cl:scale-float float integer)))

(defgeneric signum (number)
  (:documentation #.(documentation 'cl:signum 'cl:function))
  (:method ((number number))
    (cl:signum number)))

(defgeneric sinh (number)
  (:documentation #.(documentation 'cl:sinh 'cl:function))
  (:method ((number number))
    (cl:sinh number)))

(defgeneric tanh (number)
  (:documentation #.(documentation 'cl:tanh 'cl:function))
  (:method ((number number))
    (cl:tanh number)))

(defgeneric truncate (number &optional divisor)
  (:documentation #.(documentation 'cl:truncate 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:truncate number)
        (cl:truncate number divisor))))

(defgeneric zerop (number)
  (:documentation #.(documentation 'cl:zerop 'cl:function))
  (:method ((number number))
    (cl:zerop number)))

(defgeneric <2 (left right)
  (:documentation #.(documentation 'cl:< 'cl:function))
  (:method ((left number) (right number))
    (cl:< left right)))

(defun < (leftmost next &rest more)
  (fold-left (lambda (previous next)
               (and previous (<2 previous next) next))
             leftmost (cons next more)))

(defgeneric <=2 (left right)
  (:documentation #.(documentation 'cl:<= 'cl:function))
  (:method ((left number) (right number))
    (cl:<= left right)))

(defun <= (leftmost next &rest more)
  (fold-left (lambda (previous next)
               (and previous (<=2 previous next) next))
             leftmost (cons next more)))

(defgeneric =2 (left right)
  (:documentation #.(documentation 'cl:= 'cl:function))
  (:method ((left number) (right number))
    (cl:= left right)))

(defun = (leftmost next &rest more)
  (fold-left (lambda (previous next)
               (and previous (=2 previous next) next))
             leftmost (cons next more)))

(defgeneric >2 (left right)
  (:documentation #.(documentation 'cl:> 'cl:function))
  (:method ((left number) (right number))
    (cl:> left right)))

(defun > (leftmost next &rest more)
  (fold-left (lambda (previous next)
               (and previous (>2 previous next) next))
             leftmost (cons next more)))

(defgeneric >=2 (left right)
  (:documentation #.(documentation 'cl:>= 'cl:function))
  (:method ((left number) (right number))
    (cl:>= left right)))

(defun >= (leftmost next &rest more)
  (fold-left (lambda (previous next)
               (and previous (>=2 previous next) next))
             leftmost (cons next more)))

(defgeneric /=2 (left right)
  (:documentation #.(documentation 'cl:/= 'cl:function))
  (:method ((left number) (right number))
    (cl:/= left right)))

(defun /= (leftmost &rest more)
  (if (fold-left (lambda (items item)
                   (and items
                        (every (lambda (itm) (/=2 item itm)) items)
                        (cons item items)))
                 (list leftmost) more)
      t
      nil))
