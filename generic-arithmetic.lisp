;;; -*- Lisp -*-

(in-package "GENERIC-ARITHMETIC")

(defun * (&rest numbers)
  #.(documentation 'cl:* 'cl:function)
  (fold-left #'multiply2 1 numbers))

(defun + (&rest numbers)
  #.(documentation 'cl:+ 'cl:function)
  (fold-left #'add2 0 numbers))

(defun - (leftmost &rest rights)
  #.(documentation 'cl:- 'cl:function)
  (cond ((consp rights) (fold-left #'subtract2 leftmost rights))
        ((null rights)  (if (numberp leftmost)
                            (cl:- leftmost)
                            (negate leftmost)))
        (t
         (error "Invalid arguments to -: ~a" rights))))

(defun / (leftmost &rest rights)
  #.(documentation 'cl:/ 'cl:function)
  (cond ((consp rights) (fold-left #'divide2 leftmost rights))
        ((null rights)  (if (numberp leftmost)
                            (cl:/ 1 leftmost)
                            (reciprocal leftmost)))
        (t
         (error "Invalid arguments to /: ~a" rights))))

(defgeneric <2 (left right)
  (:documentation #.(documentation 'cl:< 'cl:function))
  (:method ((left number) (right number))
    (cl:< left right)))

(defun < (leftmost next &rest more)
  #.(documentation 'cl:< 'cl:function)
  (fold-left (lambda (previous next)
               (and previous (<2 previous next) next))
             leftmost (cons next more)))

(defgeneric <=2 (left right)
  (:documentation #.(documentation 'cl:<= 'cl:function))
  (:method ((left number) (right number))
    (cl:<= left right)))

(defun <= (leftmost next &rest more)
  #.(documentation 'cl:<= 'cl:function)
  (fold-left (lambda (previous next)
               (and previous (<=2 previous next) next))
             leftmost (cons next more)))

(defgeneric =2 (left right)
  (:documentation #.(documentation 'cl:= 'cl:function))
  (:method ((left number) (right number))
    (cl:= left right)))

(defun = (leftmost next &rest more)
  #.(documentation 'cl:= 'cl:function)
  (fold-left (lambda (previous next)
               (and previous (=2 previous next) next))
             leftmost (cons next more)))

(defgeneric >2 (left right)
  (:documentation #.(documentation 'cl:> 'cl:function))
  (:method ((left number) (right number))
    (cl:> left right)))

(defun > (leftmost next &rest more)
  #.(documentation 'cl:> 'cl:function)
  (fold-left (lambda (previous next)
               (and previous (>2 previous next) next))
             leftmost (cons next more)))

(defgeneric >=2 (left right)
  (:documentation #.(documentation 'cl:>= 'cl:function))
  (:method ((left number) (right number))
    (cl:>= left right)))

(defun >= (leftmost next &rest more)
  #.(documentation 'cl:>= 'cl:function)
  (fold-left (lambda (previous next)
               (and previous (>=2 previous next) next))
             leftmost (cons next more)))

(defgeneric /=2 (left right)
  (:documentation #.(documentation 'cl:/= 'cl:function))
  (:method ((left number) (right number))
    (cl:/= left right)))

(defun /= (leftmost &rest more)
  #.(documentation 'cl:/= 'cl:function)
  (if (fold-left (lambda (items item)
                   (and items
                        (every (lambda (itm) (/=2 item itm)) items)
                        (cons item items)))
                 (list leftmost) more)
      t
      nil))

(defgeneric 1+ (number)
  (:documentation #.(documentation 'cl:1+ 'cl:function))
  (:method (number)
    (add2 number 1))
  (:method ((number number))
    (cl:1+ number)))

(defgeneric 1- (number)
  (:documentation #.(documentation 'cl:1- 'cl:function))
  (:method (number)
    (subtract2 number 1))
  (:method ((number number))
    (cl:1- number)))

(defgeneric abs (number)
  (:documentation #.(documentation 'cl:abs 'cl:function))
  (:method ((number number))
    (cl:abs number)))

(defgeneric acos (number)
  (:documentation #.(documentation 'cl:acos 'cl:function))
  (:method ((number number))
    (cl:acos number)))

(defgeneric acosh (number)
  (:documentation #.(documentation 'cl:acosh 'cl:function))
  (:method ((number number))
    (cl:acosh number)))

(defgeneric add2 (left right)
  (:documentation "Add LEFT and RIGHT.")
  (:method ((left (eql 0)) right)
    right)
  (:method ((left (eql 0.0)) right)
    right)
  (:method ((left (eql 0.0d0)) right)
    right)
  (:method ((left (eql 0.0)) (right number))
    (coerce right 'single-float))
  (:method ((left (eql 0.0d0)) (right number))
    (coerce right 'double-float))
  (:method (left (right (eql 0)))
    left)
  (:method (left (right (eql 0.0)))
    left)
  (:method (left (right (eql 0.0d0)))
    left)
  (:method ((left number) (right (eql 0.0)))
    (coerce left 'single-float))
  (:method (left (right (eql 0.0d0)))
    (coerce left 'double-float))
  (:method ((left number) (right number))
    (cl:+ left right)))

(defgeneric asin (number)
  (:documentation #.(documentation 'cl:asin 'cl:function))
  (:method ((number number))
    (cl:asin number)))

(defgeneric asinh (number)
  (:documentation #.(documentation 'cl:asinh 'cl:function))
  (:method ((number number))
    (cl:asinh number)))

(defgeneric atan (number &optional denominator)
  (:documentation "Compute the arctangent of NUMBER. If DENOMINATOR is provided, compute atan(NUMBER / DENOMINATOR).")
  (:method ((number number) &optional denominator)
    (if (null denominator)
        (cl:atan number)
        (cl:atan number denominator))))

(defgeneric atanh (number)
  (:documentation #.(documentation 'cl:atanh 'cl:function))
  (:method ((number number))
    (cl:atanh number)))

(defgeneric ceiling (number &optional divisor)
  (:documentation #.(documentation 'cl:ceiling 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:ceiling number)
        (cl:ceiling number divisor))))

(defgeneric cis (number)
  (:documentation #.(documentation 'cl:cis 'cl:function))
  (:method ((number number))
    (cl:cis number)))

(defgeneric conjugate (number)
  (:documentation #.(documentation 'cl:conjugate 'cl:function))
  (:method ((number number))
    (cl:conjugate number)))

(defgeneric cos (number)
  (:documentation #.(documentation 'cl:cos 'cl:function))
  (:method ((number number))
    (cl:cos number)))

(defgeneric cosh (number)
  (:documentation #.(documentation 'cl:cosh 'cl:function))
  (:method ((number number))
    (cl:cosh number)))

(defgeneric cube (number)
  (:documentation "Compute the cube of NUMBER.")
  (:method (number)
    (multiply2 number (multiply2 number number))))

(defgeneric denominator (rational)
  (:documentation #.(documentation 'cl:denominator 'cl:function))
  (:method ((rational rational))
    (cl:denominator rational)))

(defgeneric divide2 (left right)
  (:documentation "Divide LEFT by RIGHT.")
  (:method ((left (eql 1)) right)
    (reciprocal right))
  (:method ((left (eql 1.0)) right)
    (reciprocal right))
  (:method ((left (eql 1.0d0)) right)
    (reciprocal right))
  (:method (left (right (eql 1)))
    left)
  (:method (left (right (eql 1.0)))
    left)
  (:method (left (right (eql 1.0d0)))
    left)
  (:method ((left number) (right (eql 1.0)))
    (coerce left 'single-float))
  (:method ((left number) (right (eql 1.0d0)))
    (coerce left 'double-float))
  (:method ((left number) (right number))
    (cl:/ left right))
  (:method (left right)
    (multiply2 left (reciprocal right)))
  )

(defgeneric exp (number)
  (:documentation #.(documentation 'cl:exp 'cl:function))
  (:method ((number (eql 0)))
    1)
  (:method ((number (eql 0.0)))
    1.0)
  (:method ((number (eql 0.0d0)))
    1.0d0)
  (:method ((number number))
    (cl:exp number)))

(defgeneric expt (base exponent)
  (:documentation #.(documentation 'cl:expt 'cl:function))
  (:argument-precedence-order exponent base)
  (:method (base (exponent (eql 0)))
    1)
  (:method (base (exponent (eql 0.0)))
    1.0)
  (:method (base (exponent (eql 0.0d0)))
    1.0d0)
  (:method (base (exponent (eql 1)))
    base)
  (:method ((base number) (exponent (eql 1.0)))
    (coerce base 'single-float))
  (:method ((base number) (exponent (eql 1.0d0)))
    (coerce base 'double-float))
  (:method (base (exponent integer))
    (cond ((minusp exponent) (expt (reciprocal base) (cl:- exponent)))
          ((evenp exponent)  (expt (* base base) (cl:/ exponent 2)))
          (t                 (* base (expt base (cl:- exponent 1))))))
  (:method ((base (eql 0)) exponent)
    0)
  (:method ((base (eql 0.0)) exponent)
    0.0)
  (:method ((base (eql 0.0d0)) exponent)
    0.0d0)
  (:method ((base (eql 1)) exponent)
    1)
  (:method ((base (eql 1.0)) exponent)
    1.0)
  (:method ((base (eql 1.0d0)) exponent)
    1.0d0)
  (:method ((base number) (exponent number))
    (cl:expt base exponent)))

(defgeneric floor (number &optional divisor)
  (:documentation #.(documentation 'cl:floor 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:floor number)
        (cl:floor number divisor))))

(defgeneric imagpart (number)
  (:documentation #.(documentation 'cl:imagpart 'cl:function))
  (:method ((number number))
    (cl:imagpart number)))

(defgeneric log (number &optional base)
  (:documentation #.(documentation 'cl:log 'cl:function))
  (:method ((number (eql 1)) &optional base)
    0)
  (:method ((number (eql 1.0)) &optional base)
    0.0)
  (:method ((number (eql 1.0d0)) &optional base)
    0.0d0)
  (:method ((number number) &optional base)
    (cl:log number (or base (cl:exp 1.0d0)))))

(defgeneric max2 (left right)
  (:documentation #.(documentation 'cl:max 'cl:function))
  (:method ((left number) (right number))
    (cl:max left right)))

(defun max (leftmost &rest more-numbers)
  #.(documentation 'cl:max 'cl:function)
  (fold-left #'max2 leftmost more-numbers))

(defgeneric min2 (left right)
  (:documentation #.(documentation 'cl:min 'cl:function))
  (:method ((left number) (right number))
    (cl:min left right)))

(defun min (leftmost &rest more-numbers)
  #.(documentation 'cl:min 'cl:function)
  (fold-left #'min2 leftmost more-numbers))

(defgeneric mod (number divisor)
  (:documentation #.(documentation 'cl:mod 'cl:function))
  (:method ((number number) (divisor number))
    (cl:mod number divisor)))

(defgeneric multiply2 (left right)
  (:documentation "Multiply LEFT by RIGHT.")
  (:method ((left (eql 0)) right)
    0)
  (:method ((left (eql 0.0)) right)
    0.0)
  (:method ((left (eql 0.0d0)) right)
    0.0d0)
  (:method ((left (eql 1)) right)
    right)
  (:method ((left (eql 1.0)) right)
    right)
  (:method ((left (eql 1.0d0)) right)
    right)
  (:method ((left (eql 1.0)) (right number))
    (coerce right 'single-float))
  (:method ((left (eql 1.0d0)) right)
    (coerce right 'double-float))
  (:method (left (right (eql 0)))
    0)
  (:method (left (right (eql 0.0)))
    0.0)
  (:method (left (right (eql 0.0d0)))
    0.0d0)
  (:method (left (right (eql 1)))
    left)
  (:method (left (right (eql 1.0)))
    left)
  (:method (left (right (eql 1.0d0)))
    left)
  (:method ((left number) (right (eql 1.0)))
    (coerce left 'single-float))
  (:method ((left number) (right (eql 1.0d0)))
    (coerce left 'double-float))
  (:method ((left number) (right number))
    (cl:* left right)))

(defgeneric negate (number)
  (:documentation "Return (- number)")
  (:method ((number number))
    (cl:- number)))

(defgeneric numerator (rational)
  (:documentation #.(documentation 'cl:numerator 'cl:function))
  (:method ((rational rational))
    (cl:numerator rational)))

(defgeneric phase (number)
  (:documentation #.(documentation 'cl:phase 'cl:function))
  (:method ((number number))
    (cl:phase number)))

(defgeneric random (arg)
  (:documentation #.(documentation 'cl:random 'cl:function))
  (:method ((arg number))
    (cl:random arg)))

(defgeneric rationalize (number)
  (:documentation #.(documentation 'cl:rationalize 'cl:function))
  (:method ((number number))
    (cl:rationalize number)))

(defgeneric realpart (number)
  (:documentation #.(documentation 'cl:realpart 'cl:function))
  (:method ((number number))
    (cl:realpart number)))

(defgeneric reciprocal (number)
  (:documentation "Return 1/number.")
  (:method ((number number))
    (cl:/ 1 number)))

(defgeneric rem (number divisor)
  (:documentation #.(documentation 'cl:rem 'cl:function))
  (:method ((number number) (divisor number))
    (cl:rem number divisor)))

(defgeneric round (number &optional divisor)
  (:documentation #.(documentation 'cl:round 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:round number)
        (cl:round number divisor))))

(defgeneric signum (number)
  (:documentation #.(documentation 'cl:signum 'cl:function))
  (:method ((number number))
    (cl:signum number)))

(defgeneric sin (number)
  (:documentation #.(documentation 'cl:sin 'cl:function))
  (:method ((number number))
    (cl:sin number)))

(defgeneric sinh (number)
  (:documentation #.(documentation 'cl:sinh 'cl:function))
  (:method ((number number))
    (cl:sinh number)))

(defgeneric sqrt (number)
  (:documentation #.(documentation 'cl:sqrt 'cl:function))
  (:method ((number number))
    (cl:sqrt number)))

(defgeneric square (number)
  (:documentation "Compute the square of NUMBER.")
  (:method (number)
    (multiply2 number number)))

(defgeneric subtract2 (left right)
  (:documentation "Subtract RIGHT from LEFT.")
  (:method ((left (eql 0)) right)
    (negate right))
  (:method ((left (eql 0.0)) right)
    (negate right))
  (:method ((left (eql 0.0d0)) right)
    (negate right))
  (:method ((left (eql 0)) (right number))
    (cl:- right))
  (:method ((left (eql 0.0)) (right number))
    (cl:- (coerce right 'single-float)))
  (:method ((left (eql 0.0d0)) (right number))
    (cl:- (coerce right 'double-float)))
  (:method (left (right (eql 0)))
    left)
  (:method (left (right (eql 0.0)))
    left)
  (:method (left (right (eql 0.0d0)))
    left)
  (:method ((left number) (right (eql 0.0)))
    (coerce left 'single-float))
  (:method (left (right (eql 0.0d0)))
    (coerce left 'double-float))
  (:method (left right)
    (add2 left (negate right)))
  (:method ((left number) (right number))
    (cl:- left right)))

(defgeneric tan (number)
  (:documentation #.(documentation 'cl:tan 'cl:function))
  (:method ((number number))
    (cl:tan number)))

(defgeneric tanh (number)
  (:documentation #.(documentation 'cl:tanh 'cl:function))
  (:method ((number number))
    (cl:tanh number)))

(defgeneric truncate (number &optional divisor)
  (:documentation #.(documentation 'cl:truncate 'cl:function))
  (:method ((number number) &optional divisor)
    (if (null divisor)
        (cl:truncate number)
        (cl:truncate number divisor))))

(defgeneric zerop (number)
  (:documentation #.(documentation 'cl:zerop 'cl:function))
  (:method ((number number))
    (cl:zerop number)))
